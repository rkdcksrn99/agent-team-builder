# Spawn Team Script Templates

Use these as the base when generating spawn scripts in Step 7.
Adapt based on the user's approved communication pattern.

---

## spawn_team.sh (Bash)

```bash
#!/usr/bin/env bash
# spawn_team.sh — {{PROJECT_NAME}} Agent Team Bootstrapper
# Generated by agent-team-builder skill
# Pattern: {{COMMUNICATION_PATTERN}}

set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG="$PROJECT_ROOT/AGENT_CONFIG.md"
TEAMS="$PROJECT_ROOT/TEAMS.md"
OUTPUTS="$PROJECT_ROOT/outputs"

# Create outputs directory
mkdir -p "$OUTPUTS"

echo "=== {{PROJECT_NAME}} Agent Team ==="
echo "Pattern: {{COMMUNICATION_PATTERN}}"
echo "Agents: {{AGENT_COUNT}}"
echo ""

# ─── UTILITY ────────────────────────────────────────────────────────────────

run_agent() {
  local agent_name="$1"
  local input_file="$2"
  local output_file="$3"

  echo "→ Running $agent_name..."

  claude -p "$(cat "$PROJECT_ROOT/prompts/${agent_name}.md")" \
    --context "$TEAMS" \
    --input "$input_file" \
    > "$output_file" 2>&1

  if [ $? -ne 0 ]; then
    echo "✗ $agent_name failed. See $output_file for details."
    exit 1
  fi

  echo "✓ $agent_name complete → $output_file"
}

# ─── AGENT EXECUTION ────────────────────────────────────────────────────────
# {{PATTERN: Sequential Pipeline example — replace with your pattern}}

# Stage 1: PM Agent
run_agent "pm" \
  "$PROJECT_ROOT/inputs/task.json" \
  "$OUTPUTS/pm_output.json"

# Stage 2: {{NEXT_AGENT}}
run_agent "{{next_agent}}" \
  "$OUTPUTS/pm_output.json" \
  "$OUTPUTS/{{next_agent}}_output.json"

# Add stages based on your communication pattern...

echo ""
echo "=== Team run complete ==="
echo "Outputs: $OUTPUTS/"
```

---

## spawn_team.py (Python)

```python
#!/usr/bin/env python3
"""
spawn_team.py — {{PROJECT_NAME}} Agent Team Bootstrapper
Generated by agent-team-builder skill
Pattern: {{COMMUNICATION_PATTERN}}
"""

import json
import subprocess
import sys
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent
OUTPUTS = PROJECT_ROOT / "outputs"
OUTPUTS.mkdir(exist_ok=True)

AGENTS = [
    # Define your agents in execution order
    # (name, input_source, output_file, prompt_file)
    ("pm",           "inputs/task.json",        "outputs/pm_output.json",     "prompts/pm.md"),
    ("{{agent2}}",   "outputs/pm_output.json",  "outputs/{{agent2}}_out.json","prompts/{{agent2}}.md"),
    # Add more agents here...
]


def run_agent(name: str, input_path: str, output_path: str, prompt_path: str) -> bool:
    """Run a single agent via Claude CLI."""
    print(f"→ Running {name}...")

    prompt = (PROJECT_ROOT / prompt_path).read_text()
    teams_context = (PROJECT_ROOT / "TEAMS.md").read_text()

    try:
        result = subprocess.run(
            ["claude", "-p", prompt, "--context", teams_context],
            input=(PROJECT_ROOT / input_path).read_text(),
            capture_output=True,
            text=True,
            timeout=120
        )

        if result.returncode != 0:
            print(f"✗ {name} failed:\n{result.stderr}")
            return False

        (PROJECT_ROOT / output_path).write_text(result.stdout)
        print(f"✓ {name} complete → {output_path}")
        return True

    except subprocess.TimeoutExpired:
        print(f"✗ {name} timed out after 120s")
        return False


def run_sequential(agents: list) -> None:
    """Run agents in a sequential pipeline."""
    for name, input_path, output_path, prompt_path in agents:
        success = run_agent(name, input_path, output_path, prompt_path)
        if not success:
            print(f"\nPipeline halted at {name}.")
            sys.exit(1)


def run_parallel(agents: list) -> None:
    """Run agents in parallel (fan-out). Requires all to share the same input."""
    import concurrent.futures

    results = {}
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = {
            executor.submit(run_agent, *agent): agent[0]
            for agent in agents
        }
        for future in concurrent.futures.as_completed(futures):
            agent_name = futures[future]
            results[agent_name] = future.result()

    failed = [name for name, success in results.items() if not success]
    if failed:
        print(f"\nFailed agents: {', '.join(failed)}")
        # Define your minimum viable threshold here
        if len(failed) > len(agents) // 2:
            print("Too many failures. Halting.")
            sys.exit(1)


if __name__ == "__main__":
    print(f"=== {{PROJECT_NAME}} Agent Team ===")
    print(f"Pattern: {{COMMUNICATION_PATTERN}}")
    print(f"Agents: {len(AGENTS)}")
    print()

    # Choose your pattern:
    run_sequential(AGENTS)  # or run_parallel(AGENTS) for fan-out

    print("\n=== Team run complete ===")
    print(f"Outputs: {OUTPUTS}/")
```

---

## Pattern-Specific Notes

### Sequential Pipeline
Use `run_sequential()`. Output of each agent is the input for the next.
Ensure each agent's output format matches the next agent's expected input.

### Hub & Spoke
Run PM Agent first. Parse its output to determine which specialists to invoke.
Invoke specialists (can be parallel), then run PM Agent again to aggregate.

### Parallel Fan-Out
Use `run_parallel()` for the fan-out stage. Define an aggregator that runs after.
Set a minimum viable threshold (e.g., proceed if ≥ 2/3 agents succeed).

### Hybrid
Combine `run_sequential()` for pipeline stages and `run_parallel()` for fan-out stages.
Structure as named stages with clear entry/exit points.
